"""
Provide the business logic for Mangiato API users. All functions
related to user: create, update, delete and get users; block users, etc,
"""
import os
from datetime import datetime
from flask import render_template, url_for
from flask_restplus import marshal
from pyparsing import ParseException
from sqlalchemy import and_, or_
from mangiato.database import DB
from mangiato.database.models import User, Role, Profile
from mangiato.constants import (COMMON_USER_ROLE, RESPONSES_CATALOG,
                                CODE_CREATED, CODE_CONFLICT, CODE_OK,
                                CODE_NOT_FOUND, ADMIN_ROLE, MANAGER_ROLE,
                                CODE_FORBIDDEN, CODE_NOT_ACCEPTABLE,
                                CODE_NO_CONTENT, EMAIL_REGEX, FIELDS_USERS,
                                CODE_INTERNAL_ERROR)
from mangiato.globals import get_roles_user, APP
from mangiato.api.parsers import PAGE_ARGUMENTS_USERS
from mangiato.api.serializers import (USER_WITH_ENTRIES, USER_DESCRIPTION,
                                      PAGE_OF_USERS_ADMIN,
                                      PAGE_OF_USERS_MANAGER)
from mangiato.api.verification import (generate_confirmation_token,
                                       confirm_token, send_email)
from mangiato.api.filtering import process_query


def create_user(data):
    """
    Create a new user in server storing in database with information coming
    from data.
    :param data: Information to create the new user
    :type: json
    :return: New user created, error message otherwise. HTTP status code
    :type: tuple(json, int)
    """

    first_name = data.get('first_name')
    last_name = data.get('last_name')
    email = data.get('username')
    password = data.get('password')
    if EMAIL_REGEX.match(email):
        user_in_db = User.query.filter(User.username == email).first()
        if not user_in_db:
            user = User(email, first_name, last_name, password)
            role_common_user = Role.query.filter(Role.name ==
                                                 COMMON_USER_ROLE).first()
            user.roles.append(role_common_user)
            profile = Profile(user)
            DB.session.add(user)
            DB.session.add(profile)
            DB.session.commit()
            token_account_verification = \
                generate_confirmation_token(user.username)
            confirm_url = url_for('api.v1/users_email_confirmation',
                                  token=token_account_verification,
                                  _external=True)
            html = render_template('activate.html',
                                   confirm_url=confirm_url)
            subject = "Mangiato: Please confirm your email"
            send_email(user.username, subject, html)
            response = RESPONSES_CATALOG['mail_sent']
            code = CODE_CREATED
        else:
            response = RESPONSES_CATALOG['existing_user']
            code = CODE_CONFLICT
    else:
        response = RESPONSES_CATALOG['no_format_email']
        code = CODE_NOT_ACCEPTABLE
    return response, code


def confirm_email_business(token):
    """
    Get the email corresponding with the provided token, decide of the user
    exists in the server and confirm the account. Error message if the user is
    already confirmed or if the token provided is not a valid token
    :param token: Token to get the email account to confirm. In general will
    be a token generated by the system
    :type: str
    :return: A message about account confirmation, error otherwise.
    :type: tuple(json, int)
    """
    email = confirm_token(token)
    if email:
        user = User.query.filter_by(username=email).first()
        if user:
            if user.confirmed:
                response = \
                    _add_links_response(RESPONSES_CATALOG['already_confirmed'],
                                        str(user.id))
                code = CODE_OK
            else:
                user.confirmed = True
                user.confirmed_on = datetime.now()
                DB.session.add(user)
                DB.session.commit()
                response = _add_links_response(RESPONSES_CATALOG['confirmed'],
                                               str(user.id))
                code = CODE_OK
        else:
            response = RESPONSES_CATALOG['no_user_link']
            code = CODE_NOT_FOUND
    else:
        response = RESPONSES_CATALOG['invalid_link']
        code = CODE_NOT_FOUND
    return response, code


def _add_links_response(response_input, user_id):
    """
    Add links to response of user created
    :param response_input: Dictionary of responses
    :type: dict
    :param user_id: user id to be included in the link to add
    :type: int
    :return: Dictionary with responses modified
    :type: dict
    """
    url_profile = url_for(
        'api.v1/users/<int:id_user>/profile_profile',
        id_user=user_id,
        _external=True, _scheme='https')

    url_avatar = url_for('api.v1/users/<int:id_user>/profile/'
                         'avatar_avatar',
                         id_user=user_id,
                         _external=True, _scheme='https')
    url_meals = url_for('api.v1/users/<int:id_user>/meals_meals',
                        id_user=user_id,
                        _external=True, _scheme='https')
    response = dict(response_input)
    response['id_user'] = str(user_id)
    response['response'] = response['response'].format(id_user=str(user_id))

    response['links']['url_profile']['link'] = url_profile
    response['links']['url_avatar']['link'] = url_avatar
    response['links']['url_meals']['link'] = url_meals
    return response


def get_user(id_user, user):
    """
    Get an user from database corresponding to id_user, the requester must
    have permission to get the user. Only admins and managers can request an
    user from database
    :param id_user: User's id to get from database
    :type: int
    :param user: User who made the request
    :type: User Model
    :return: Information about the user required in json format. HTTP status
    code
    :type: tuple(json, int)
    """
    roles = get_roles_user(user)
    if roles.intersection({ADMIN_ROLE, MANAGER_ROLE}):
        if roles.intersection({ADMIN_ROLE}):
            model_serializer = USER_WITH_ENTRIES
        else:
            model_serializer = USER_DESCRIPTION
        user = User.query.filter(User.id == id_user).first()
        if user:
            response = marshal(user, model_serializer)
            code = CODE_OK
        else:
            response = dict(RESPONSES_CATALOG['no_user_server'])
            response['error'] = response['error'].format(id_user=id_user)
            code = CODE_NOT_FOUND
    else:
        response = dict(RESPONSES_CATALOG['no_permission_resource'])
        response['error'] = response['error'].format(id_user=user.id)
        code = CODE_FORBIDDEN
    return response, code


def get_users(request, user):
    """
    Get the list of users registered on the server. The requester must
    have permission to get list of users. Only admins and managers can request
    an user from database.
    :param request: Information about the request done
    :type: LocalProxy
    :param user: User who made the request
    :type: User Model
    :return: List of users in json format. HTTP status code
    :type: tuple(json, int)
    """
    roles = get_roles_user(user)
    if roles.intersection({ADMIN_ROLE, MANAGER_ROLE}):
        if roles.intersection({ADMIN_ROLE}):
            model_serializer = PAGE_OF_USERS_ADMIN
        else:
            model_serializer = PAGE_OF_USERS_MANAGER
        args = PAGE_ARGUMENTS_USERS.parse_args(request)
        page = args.get('page', 1)
        per_page = args.get('per_page', 10)
        sort = args.get('sort', 'id')
        if sort not in FIELDS_USERS:
            response = {'error': 'Non acceptable ordering: ' + sort}
            code = CODE_NOT_ACCEPTABLE
            return response, code
        search = args.get('search')
        filter_query = ""
        model = 'User'
        try:
            if search:
                search = search.lower()
                query_string = process_query(model, search)
                filter_query = ".filter({})".format(query_string)
            string_filter = model + ".query.order_by(" + model + "." + sort + \
                            ")" + filter_query + ".paginate(page, per_page, " \
                                                 "error_out=False)"
            users_page = eval(string_filter)
            response = marshal(users_page, model_serializer)
            code = CODE_OK
        except ParseException:
            response = RESPONSES_CATALOG['error_parse_query_values']
            code = CODE_NOT_ACCEPTABLE
        except AttributeError as error:
            response = dict(RESPONSES_CATALOG['error_parse_query_fields'])
            response['error'] = response['error'].format(field_error=error)
            code = CODE_NOT_ACCEPTABLE
        except Exception as error:
            response = dict(RESPONSES_CATALOG['internal_error_server'])
            response['error'] = response['error'] + str(error)
            code = CODE_INTERNAL_ERROR
    else:
        response = dict(RESPONSES_CATALOG['no_permission_resource'])
        response['error'] = response['error'].format(id_user=user.id)
        code = CODE_FORBIDDEN
    return response, code


def update_user(id_user, data, user_input):
    """
    Update information of an user on database. All fields of user are required
    :param id_user: user id corresponding to user to update information
    :type: int
    :param data: new information to store in the user
    :type: json
    :param user_input: User who made the request
    :type: User Model
    :return: User updated if succes, error message otherwise. HTTP status code
    :type: tuple(json, int)
    """
    roles = get_roles_user(user_input)
    if roles.intersection({ADMIN_ROLE, MANAGER_ROLE}):
        user = User.query.filter(User.id == id_user).first()
        if not user:
            response = dict(RESPONSES_CATALOG['no_user_server'])
            response['error'] = response['error'].format(id_user=id_user)
            code = CODE_NOT_FOUND
        else:
            user.username = data.get('username')
            user.first_name = data.get('first_name')
            user.last_name = data.get('last_name')
            user.confirmed = bool(data.get('confirmed'))
            user.confirmed_on = datetime.strptime(data.get('confirmed_on'),
                                                  '%Y-%m-%d')
            user.attempts_login = int(data.get('attempts_login'))
            user.blocked = bool(data.get('blocked'))
            new_role_user = data.get('roles')
            user.roles = []
            for role in new_role_user:
                name_role = role["name"]
                role_object = Role.query.filter(Role.name == name_role).first()
                user.roles.append(role_object)
            DB.session.add(user)
            DB.session.commit()
            response = marshal(user, USER_DESCRIPTION)
            code = CODE_OK
    else:
        response = dict(RESPONSES_CATALOG['no_permission_update_resource'])
        response['error'] = response['error'].format(id_user=user_input.id)
        code = CODE_FORBIDDEN
    return response, code


def patch_user(id_user, data, user_input):
    """
    Update information of an user on database. Not all fields are required in
    this case, this function can be used to unblock users accounts for instance
    :param id_user: user id corresponding to user to update information
    :type: int
    :param data: new information to store in the user
    :type: json
    :param user_input: User who made the request
    :type: User Model
    :return: User updated if success, error message otherwise. HTTP status code
    :type: tuple(json, int)
    """
    roles = get_roles_user(user_input)
    if roles.intersection({ADMIN_ROLE, MANAGER_ROLE}):
        user = User.query.filter(User.id == id_user).first()
        if not user:
            response = dict(RESPONSES_CATALOG['no_user_server'])
            response['error'] = response['error'].format(id_user=id_user)
            code = CODE_NOT_FOUND
        else:
            if data.get('username') is not None:
                user.username = data.get('username')
            if data.get('first_name') is not None:
                user.first_name = data.get('first_name')
            if data.get('last_name') is not None:
                user.last_name = data.get('last_name')
            if data.get('confirmed') is not None:
                user.confirmed = bool(data.get('confirmed'))
            if data.get('confirmed_on') is not None:
                user.confirmed_on = datetime.strptime(data.get('confirmed_on'),
                                                      '%Y-%m-%d')
            if data.get('attempts_login') is not None:
                user.attempts_login = int(data.get('attempts_login'))
            if data.get('blocked') is not None:
                user.blocked = bool(data.get('blocked'))
            if data.get('roles') is not None:
                new_role_user = data.get('roles')
                user.roles = []
                for role in new_role_user:
                    name_role = role["name"]
                    role_object = Role.query.filter(Role.name ==
                                                    name_role).first()
                    user.roles.append(role_object)
            DB.session.add(user)
            DB.session.commit()
            response = marshal(user, USER_DESCRIPTION)
            code = CODE_OK
    else:
        response = dict(RESPONSES_CATALOG['no_permission_update_resource'])
        response['error'] = response['error'].format(id_user=user_input.id)
        code = CODE_FORBIDDEN
    return response, code


def delete_user(id_user, user_input):
    """
    Delete a user from the database and the server. The requester must have
    permission to perform deletion. The deletion of an user also will delete
    all meals related to it
    :param id_user: user id to delete
    :type: int
    :param user_input: User who made the request
    :type: User Model
    :return: An message of deletion confirmation. error message otherwise.
    HTTP status code
    :type: tuple(json, int)
    """
    roles = get_roles_user(user_input)
    if roles.intersection({ADMIN_ROLE, MANAGER_ROLE}) and \
            user_input.id != id_user:
        user = User.query.filter(User.id == id_user).first()
        if not user:
            response = dict(RESPONSES_CATALOG['no_user_server'])
            response['error'] = response['error'].format(id_user=id_user)
            code = CODE_NOT_FOUND
        else:
            roles_user_to_delete = get_roles_user(user)
            if roles.intersection({ADMIN_ROLE}):
                permission_for_delete = True
            else:
                if roles_user_to_delete.intersection({ADMIN_ROLE}):
                    permission_for_delete = False
                else:
                    permission_for_delete = True
            if permission_for_delete:
                profile_user = Profile.query.filter(Profile.user_id ==
                                                    id_user).first()
                avatars_path = APP.config['AVATARS_SAVE_PATH']
                os.remove(os.path.join(avatars_path,
                                       profile_user.name_picture_s))
                os.remove(os.path.join(avatars_path,
                                       profile_user.name_picture_m))
                os.remove(os.path.join(avatars_path,
                                       profile_user.name_picture_l))
                DB.session.delete(user)
                DB.session.commit()
                response = RESPONSES_CATALOG['user_deleted']
                code = CODE_NO_CONTENT
            else:
                response = \
                    dict(RESPONSES_CATALOG['no_permission_delete_resource'])
                response['error'] = \
                    response['error'].format(id_user=user_input.id)
                code = CODE_FORBIDDEN
    else:
        response = dict(RESPONSES_CATALOG['no_permission_delete_resource'])
        response['error'] = response['error'].format(id_user=user_input.id)
        code = CODE_FORBIDDEN
    return response, code
